<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AUI Framework: /home/runner/work/aui/aui/aui.core/src/AUI/Common/AProperty.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doxygen.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AUI Framework
   &#160;<span id="projectnumber">develop</span>
   </div>
   <div id="projectbrief">Cross-platform module-based framework for developing  C++20 desktop applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_2home_2runner_2work_2aui_2aui_2aui_8core_2src_2AUI_2Common_2AProperty_8h-example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/runner/work/aui/aui/aui.core/src/AUI/Common/AProperty.h</div>  </div>
</div><!--header-->
<div class="contents">
<p>Basic easy-to-use property implementation containing T.</p>
<p><code><a class="el" href="structAProperty.html">AProperty</a>&lt;T&gt;</code> is a container holding an instance of <code>T</code>. You can assign a value to it with <code>operator=</code> and read value with <code>value()</code> method or implicit conversion <code>operator T()</code>.</p>
<p>See <a class="el" href="group__property__system.html">property system</a> for more info.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">  <a name="_a0"></a><a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">  <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> surname;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// AProperty behaves like a class/struct data member:</span></div>
<div class="line">User u;</div>
<div class="line">u.name = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">EXPECT_EQ(u.name, <span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="ttc" id="astructAProperty_html"><div class="ttname"><a href="structAProperty.html">AProperty</a></div><div class="ttdef"><b>Definition:</b> AProperty.h:157</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * AUI Framework - Declarative UI toolkit for modern C++20</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2020-2024 Alex2772 and Contributors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * SPDX-License-Identifier: MPL-2.0</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This Source Code Form is subject to the terms of the Mozilla Public</span></div>
<div class="line"><span class="comment"> * License, v. 2.0. If a copy of the MPL was not distributed with this</span></div>
<div class="line"><span class="comment"> * file, You can obtain one at http://mozilla.org/MPL/2.0/.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;AUI/Common/ASignal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;AUI/Common/APropertyPrecomputed.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>aui::detail::property {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Projection, <span class="keyword">typename</span> Source&gt;</div>
<div class="line">concept ProjectionBidirectional = requires (Projection&amp;&amp; projectionBidirectional, Source&amp;&amp; source) {</div>
<div class="line">    <span class="comment">// projection must accept SOURCE type.</span></div>
<div class="line">    { projectionBidirectional } -&gt; aui::invocable&lt;const Source&amp;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// projection must be able to accept DESTINATION type to perform the opposite conversion.</span></div>
<div class="line">    { projectionBidirectional } -&gt; aui::invocable&lt;const std::invoke_result_t&lt;Projection, const Source&amp;&gt;&amp;&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// projection&#39;s SOURCE type must be distinguishable from DESTINATION type.</span></div>
<div class="line">    requires not aui::same_as&lt;std::decay_t&lt;decltype(projectionBidirectional(source))&gt;, std::decay_t&lt;Source&gt;&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Property&gt;   <span class="comment">// can&#39;t use AAnyProperty here, as concept would depend on itself</span></div>
<div class="line"><span class="keyword">auto</span> makeAssignment(Property&amp;&amp; property) { <span class="comment">// note the rvalue reference template argument here:</span></div>
<div class="line">                                           <span class="comment">// pass your property as std::move(*this) if your</span></div>
<div class="line">                                           <span class="comment">// property-compliant struct is temporary! otherwise you&#39;ll</span></div>
<div class="line">                                           <span class="comment">// spend your weekend on debugging segfaults :)</span></div>
<div class="line">    <span class="keyword">using</span> Underlying = std::decay_t&lt;decltype(*property)&gt;;</div>
<div class="line">    <span class="keyword">struct </span>Invocable {</div>
<div class="line">        Property property;</div>
<div class="line">        <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> Underlying&amp; value)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keyword">const_cast&lt;</span>Property&amp;<span class="keyword">&gt;</span>(property) = std::move(value);</div>
<div class="line">        };</div>
<div class="line">    } i = { std::forward&lt;Property&gt;(property) };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a name="_a0"></a><a class="code" href="structASlotDef.html">ASlotDef</a>&lt;decltype(property.boundObject()), decltype(i)&gt; {</div>
<div class="line">        .<a name="a1"></a>boundObject = <span class="keyword">property</span>.boundObject(),</div>
<div class="line">        .invocable = std::move(i),</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Property, <span class="keyword">typename</span> Projection&gt;</div>
<div class="line"><span class="keyword">auto</span> makeReadonlyProjection(Property&amp;&amp; property, Projection&amp;&amp; projection) {</div>
<div class="line">    <span class="keyword">using</span> Underlying = std::decay_t&lt;decltype(*property)&gt;;</div>
<div class="line">    <span class="keyword">auto</span> signalProjected = <span class="keyword">property</span>.changed.projected(projection);</div>
<div class="line">    <span class="keyword">using</span> Signal = decltype(signalProjected);</div>
<div class="line">    <span class="keyword">using</span> ProjectionResult = std::invoke_result_t&lt;Projection, Underlying&gt;;</div>
<div class="line">    <span class="keyword">struct </span>PropertyReadProjection {</div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        Property wrappedProperty;</div>
<div class="line">        Projection projection;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        Signal changed;</div>
<div class="line">        PropertyReadProjection(Property wrappedProperty, Projection&amp;&amp; projection, Signal changed)</div>
<div class="line">          : wrappedProperty(wrappedProperty), projection(std::move(projection)), changed(changed) {}</div>
<div class="line">        <span class="keyword">using</span> Underlying = ProjectionResult;</div>
<div class="line"> </div>
<div class="line">        [[nodiscard]]</div>
<div class="line">        <span class="keyword">auto</span> boundObject()<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">return</span> wrappedProperty.boundObject();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        [[nodiscard]]</div>
<div class="line">        Underlying value()<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">return</span> std::invoke(projection, wrappedProperty.value());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        [[nodiscard]]</div>
<div class="line">        Underlying operator*() <span class="keyword">const</span> noexcept {</div>
<div class="line">            <span class="keywordflow">return</span> value();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        [[nodiscard]] <span class="keyword">operator</span> Underlying()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> value(); }</div>
<div class="line"> </div>
<div class="line">    };</div>
<div class="line">    static_assert(APropertyReadable&lt;PropertyReadProjection&gt;, <span class="stringliteral">&quot;PropertyReadProjection must conform with APropertyReadable&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> PropertyReadProjection(std::forward&lt;Property&gt;(property), std::forward&lt;Projection&gt;(projection), std::move(signalProjected));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PropertyReadProjection, <span class="keyword">typename</span> ProjectionWrite&gt;</div>
<div class="line"><span class="keyword">struct </span>PropertyReadWriteProjection: PropertyReadProjection {</div>
<div class="line">    ProjectionWrite projectionWrite;</div>
<div class="line">    <span class="keyword">using</span> Underlying = <span class="keyword">typename</span> PropertyReadProjection::Underlying;</div>
<div class="line">    <span class="keyword">explicit</span> PropertyReadWriteProjection(PropertyReadProjection&amp;&amp; <a name="a2"></a><a class="code" href="group__xml.html#ga06fdf594d32ebd9bf8a564fd832c6f28">read</a>, ProjectionWrite&amp;&amp; projectionWrite)</div>
<div class="line">      : PropertyReadProjection(std::move(<a class="code" href="group__xml.html#ga06fdf594d32ebd9bf8a564fd832c6f28">read</a>)), projectionWrite(std::move(projectionWrite)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;aui::convertible_to&lt;Underlying&gt; U&gt;</div>
<div class="line">    PropertyReadWriteProjection&amp; operator=(U&amp;&amp; value) noexcept {</div>
<div class="line">        this-&gt;wrappedProperty = std::invoke(projectionWrite, std::forward&lt;U&gt;(value));</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>API_AUI_CORE ::<a name="_a3"></a><a class="code" href="classAObject.html">AObject</a>;</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    auto assignment() noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeAssignment(std::move(*<span class="keyword">this</span>));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Property, aui::not_overloaded_lambda ProjectionRead, aui::not_overloaded_lambda ProjectionWrite&gt;</div>
<div class="line"><span class="keyword">auto</span> makeBidirectionalProjection(Property&amp;&amp; property, ProjectionRead&amp;&amp; projectionRead, ProjectionWrite&amp;&amp; projectionWrite) {</div>
<div class="line">    <span class="keyword">auto</span> readProjected =</div>
<div class="line">        makeReadonlyProjection(std::forward&lt;Property&gt;(property), std::forward&lt;ProjectionRead&gt;(projectionRead));</div>
<div class="line">    <span class="keyword">using</span> PropertyReadProjection = decltype(readProjected);</div>
<div class="line">    PropertyReadWriteProjection result(std::move(readProjected), std::forward&lt;ProjectionWrite&gt;(projectionWrite));</div>
<div class="line"><span class="comment">//    static_assert(APropertyWritable&lt;decltype(result)&gt;, &quot;PropertyReadWriteProjection must conform with APropertyWriteable&quot;);</span></div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template&lt;typename Property, ProjectionBidirectional&lt;typename std::decay_t&lt;Property&gt;::Underlying&gt; Projection&gt;</div>
<div class="line"><span class="keyword">auto</span> makeBidirectionalProjection(Property&amp;&amp; property, Projection&amp;&amp; projection) {</div>
<div class="line">    <span class="comment">// we must define non-overloaded lambdas for makeBidirectionalProjection overload.</span></div>
<div class="line">    <span class="keyword">using</span> Source = std::decay_t&lt;typename std::decay_t&lt;Property&gt;::Underlying&gt;;</div>
<div class="line">    <span class="keyword">using</span> Destination = std::decay_t&lt;std::invoke_result_t&lt;Projection, const Source&amp;&gt;&gt;;</div>
<div class="line">    <span class="keywordflow">return</span> makeBidirectionalProjection(</div>
<div class="line">        std::forward&lt;Property&gt;(property),</div>
<div class="line">        [projection](<span class="keyword">const</span> Source&amp; s) -&gt; Destination { <span class="keywordflow">return</span> std::invoke(projection, s); },</div>
<div class="line">        [projection](<span class="keyword">const</span> Destination&amp; d) -&gt; Source { <span class="keywordflow">return</span> std::invoke(projection, d); });</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structAProperty.html">AProperty</a>: <a name="_a4"></a><a class="code" href="classAObjectBase.html">AObjectBase</a> {</div>
<div class="line">    <span class="keyword">using</span> Underlying = T;</div>
<div class="line"> </div>
<div class="line">    T raw;</div>
<div class="line">    <a name="_a5"></a><a class="code" href="classASignal.html">emits&lt;T&gt;</a> changed;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty</a>()</div>
<div class="line">        requires aui::default_initializable&lt;T&gt;</div>
<div class="line">    = default;</div>
<div class="line"> </div>
<div class="line">    template &lt;aui::convertible_to&lt;T&gt; U&gt;</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty</a>(U&amp;&amp; value) noexcept : raw(std::forward&lt;U&gt;(value)) {}</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAObjectBase.html">AObjectBase</a>* boundObject() {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;aui::convertible_to&lt;T&gt; U&gt;</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty</a>&amp; operator=(U&amp;&amp; value) noexcept {</div>
<div class="line">        <span class="keyword">static</span> constexpr <span class="keyword">auto</span> IS_COMPARABLE = requires { this-&gt;raw == value; };</div>
<div class="line">        <span class="keywordflow">if</span> constexpr (IS_COMPARABLE) {</div>
<div class="line">            <span class="keywordflow">if</span> (this-&gt;raw == value) [[unlikely]] {</div>
<div class="line">                <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        this-&gt;raw = std::forward&lt;U&gt;(value);</div>
<div class="line">        <a name="a6"></a><a class="code" href="group__signal__slot.html#gac622150996edd734a10f229eb381a53f">emit</a> changed(this-&gt;raw);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;ASignalInvokable SignalInvokable&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator^(SignalInvokable&amp;&amp; t) {</div>
<div class="line">        t.invokeSignal(<span class="keyword">nullptr</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">const</span> T&amp; value() const noexcept {</div>
<div class="line">        aui::property_precomputed::addDependency(changed);</div>
<div class="line">        <span class="keywordflow">return</span> raw;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    T&amp; value() noexcept {</div>
<div class="line">        aui::property_precomputed::addDependency(changed);</div>
<div class="line">        <span class="keywordflow">return</span> raw;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">operator</span> <span class="keyword">const</span> T&amp;() <span class="keyword">const</span> noexcept { <span class="keywordflow">return</span> value(); }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">const</span> T* operator-&gt;() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> &amp;value();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">const</span> T&amp; operator*() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> value();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    T&amp; operator*() noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> value();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;aui::invocable&lt;const T&amp;&gt; Projection&gt;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> <a name="a7"></a><a class="code" href="structAProperty.html#ac532f4a4f88a531c28b8b289d8d93c28">readProjected</a>(Projection&amp;&amp; projection) noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeReadonlyProjection(*<span class="keyword">this</span>, std::forward&lt;Projection&gt;(projection));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;aui::invocable&lt;const T&amp;&gt; ProjectionRead,</div>
<div class="line">             aui::invocable&lt;const std::invoke_result_t&lt;ProjectionRead, T&gt;&amp;&gt; ProjectionWrite&gt;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> <a name="a8"></a><a class="code" href="structAProperty.html#ae2562922cd46888709005f8aa0a6bead">biProjected</a>(ProjectionRead&amp;&amp; projectionRead, ProjectionWrite&amp;&amp; projectionWrite) noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeBidirectionalProjection(*<span class="keyword">this</span>,</div>
<div class="line">                                                                  std::forward&lt;ProjectionRead&gt;(projectionRead),</div>
<div class="line">                                                                  std::forward&lt;ProjectionWrite&gt;(projectionWrite));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;aui::detail::property::ProjectionB<span class="keywordtype">id</span>irectional&lt;T&gt; Projection&gt;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="structAProperty.html#ae2562922cd46888709005f8aa0a6bead">biProjected</a>(Projection&amp;&amp; projectionBidirectional) noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeBidirectionalProjection(*<span class="keyword">this</span>, projectionBidirectional);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classAObject.html">AObject</a>;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> assignment() noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeAssignment(*<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">static_assert(AAnyProperty&lt;<a class="code" href="structAProperty.html">AProperty&lt;int&gt;</a>&gt;, <span class="stringliteral">&quot;AProperty does not conform AAnyProperty concept&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> M, aui::invocable&lt;M&amp;&gt; Getter, aui::invocable&lt;M&amp;, std::invoke_result_t&lt;Getter, M&amp;&gt;&gt; Setter,</div>
<div class="line">    <span class="keyword">typename</span> SignalArg&gt;</div>
<div class="line"><span class="keyword">struct </span><a name="_a9"></a><a class="code" href="structAPropertyDef.html">APropertyDef</a> {</div>
<div class="line">    <span class="keyword">const</span> M* <a name="a10"></a><a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>;</div>
<div class="line">    <span class="keyword">using</span> Model = M;</div>
<div class="line"> </div>
<div class="line">    Getter <a name="a11"></a><a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>;</div>
<div class="line"> </div>
<div class="line">    Setter <a name="a12"></a><a class="code" href="structAPropertyDef.html#a62ad81ffc5bf8b8aa5defb808984e0a9">set</a>;</div>
<div class="line">    <span class="keyword">using</span> GetterReturnT = decltype(std::invoke(<a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>, <a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>));</div>
<div class="line">    <span class="keyword">using</span> Underlying = std::decay_t&lt;GetterReturnT&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classASignal.html">emits&lt;SignalArg&gt;</a>&amp; <a name="a13"></a><a class="code" href="structAPropertyDef.html#a876e5b8fc0f3fda02585e8265f5b9a29">changed</a>;</div>
<div class="line">    static_assert(aui::same_as&lt;Underlying , std::decay_t&lt;SignalArg&gt;&gt;, <span class="stringliteral">&quot;different getter result and signal arg?&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// this ctor effectively prohibits designated initialization, i.e., this one is not possible:</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// auto size() const {</span></div>
<div class="line">    <span class="comment">//     return APropertyDef {</span></div>
<div class="line">    <span class="comment">//         .base = this,</span></div>
<div class="line">    <span class="comment">//         .get = &amp;AView::mSize,</span></div>
<div class="line">    <span class="comment">//         .set = &amp;AView::setSize,</span></div>
<div class="line">    <span class="comment">//         .changed = mSizeChanged,</span></div>
<div class="line">    <span class="comment">//     };</span></div>
<div class="line">    <span class="comment">// }</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// deduction in designated initializers is relatively recent feature.</span></div>
<div class="line">    <a class="code" href="structAPropertyDef.html">APropertyDef</a>(<span class="keyword">const</span> M* <a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>, Getter <a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>, Setter <a class="code" href="structAPropertyDef.html#a62ad81ffc5bf8b8aa5defb808984e0a9">set</a>, <span class="keyword">const</span> <a class="code" href="classASignal.html">emits&lt;SignalArg&gt;</a>&amp; <a class="code" href="structAPropertyDef.html#a876e5b8fc0f3fda02585e8265f5b9a29">changed</a>)</div>
<div class="line">      : <a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>(<a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>), <a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>(std::move(<a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>)), <a class="code" href="structAPropertyDef.html#a62ad81ffc5bf8b8aa5defb808984e0a9">set</a>(std::move(<a class="code" href="structAPropertyDef.html#a62ad81ffc5bf8b8aa5defb808984e0a9">set</a>)), <a class="code" href="structAPropertyDef.html#a876e5b8fc0f3fda02585e8265f5b9a29">changed</a>(<a class="code" href="structAPropertyDef.html#a876e5b8fc0f3fda02585e8265f5b9a29">changed</a>) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;aui::convertible_to&lt;Underlying&gt; U&gt;</div>
<div class="line">    <a class="code" href="structAPropertyDef.html">APropertyDef</a>&amp; operator=(U&amp;&amp; u) {</div>
<div class="line">        std::invoke(<a class="code" href="structAPropertyDef.html#a62ad81ffc5bf8b8aa5defb808984e0a9">set</a>, *<span class="keyword">const_cast&lt;</span>Model*<span class="keyword">&gt;</span>(<a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>), std::forward&lt;U&gt;(u));</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    GetterReturnT value() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> std::invoke(<a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>, <a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    GetterReturnT operator*() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> std::invoke(<a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>, <a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">const</span> Underlying* operator-&gt;() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> &amp;std::invoke(<a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>, <a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">operator</span> GetterReturnT() const noexcept { <span class="keywordflow">return</span> std::invoke(<a class="code" href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">get</a>, <a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>); }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    M* boundObject()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>M*<span class="keyword">&gt;</span>(<a class="code" href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">base</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;aui::invocable&lt;const Underlying&amp;&gt; Projection&gt;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> <a name="a14"></a><a class="code" href="structAPropertyDef.html#ae6180044dbbbcfb59a4abb797b4f3f24">readProjected</a>(Projection&amp;&amp; projection) noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeReadonlyProjection(std::move(*<span class="keyword">this</span>), std::forward&lt;Projection&gt;(projection));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;</div>
<div class="line">        aui::invocable&lt;const Underlying&amp;&gt; ProjectionRead,</div>
<div class="line">        aui::invocable&lt;const std::invoke_result_t&lt;ProjectionRead, Underlying&gt;&amp;&gt; ProjectionWrite&gt;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> <a name="a15"></a><a class="code" href="structAPropertyDef.html#a79796c83902226291120377ae6bf0b9e">biProjected</a>(ProjectionRead&amp;&amp; projectionRead, ProjectionWrite&amp;&amp; projectionWrite) noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeBidirectionalProjection(</div>
<div class="line">            std::move(*<span class="keyword">this</span>), std::forward&lt;ProjectionRead&gt;(projectionRead),</div>
<div class="line">            std::forward&lt;ProjectionWrite&gt;(projectionWrite));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;aui::detail::property::ProjectionB<span class="keywordtype">id</span>irectional&lt;Underlying&gt; Projection&gt;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="structAPropertyDef.html#a79796c83902226291120377ae6bf0b9e">biProjected</a>(Projection&amp;&amp; projectionBidirectional) noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeBidirectionalProjection(std::move(*<span class="keyword">this</span>), projectionBidirectional);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classAObject.html">AObject</a>;</div>
<div class="line">    [[nodiscard]]</div>
<div class="line">    <span class="keyword">auto</span> assignment() noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> aui::detail::property::makeAssignment(std::move(*<span class="keyword">this</span>));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// binary operations for properties.</span></div>
<div class="line"><span class="keyword">template</span>&lt;AAnyProperty Lhs, <span class="keyword">typename</span> Rhs&gt;</div>
<div class="line">[[nodiscard]]</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> operator==(<span class="keyword">const</span> Lhs&amp; lhs, Rhs&amp;&amp; rhs) {</div>
<div class="line">    <span class="keywordflow">return</span> *lhs == std::forward&lt;Rhs&gt;(rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;AAnyProperty Lhs, <span class="keyword">typename</span> Rhs&gt;</div>
<div class="line">[[nodiscard]]</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> operator!=(<span class="keyword">const</span> Lhs&amp; lhs, Rhs&amp;&amp; rhs) {</div>
<div class="line">    <span class="keywordflow">return</span> *lhs != std::forward&lt;Rhs&gt;(rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;AAnyProperty Lhs, <span class="keyword">typename</span> Rhs&gt;</div>
<div class="line">[[nodiscard]]</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> operator+(<span class="keyword">const</span> Lhs&amp; lhs, Rhs&amp;&amp; rhs) {</div>
<div class="line">    <span class="keywordflow">return</span> *lhs + std::forward&lt;Rhs&gt;(rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;AAnyProperty Lhs, <span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="keyword">inline</span> decltype(<span class="keyword">auto</span>) operator+=(Lhs&amp; lhs, Rhs&amp;&amp; rhs) {</div>
<div class="line">    *lhs += std::forward&lt;Rhs&gt;(rhs);</div>
<div class="line">    <span class="keywordflow">return</span> lhs;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;AAnyProperty Lhs, <span class="keyword">typename</span> Rhs&gt;</div>
<div class="line"><span class="keyword">inline</span> decltype(<span class="keyword">auto</span>) operator+=(Lhs&amp;&amp; lhs, Rhs&amp;&amp; rhs) {</div>
<div class="line">    <span class="keywordflow">return</span> lhs = *lhs + std::forward&lt;Rhs&gt;(rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;AAnyProperty Lhs, <span class="keyword">typename</span> Rhs&gt;</div>
<div class="line">[[nodiscard]]</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> operator-(<span class="keyword">const</span> Lhs&amp; lhs, Rhs&amp;&amp; rhs) {</div>
<div class="line">    <span class="keywordflow">return</span> *lhs - std::forward&lt;Rhs&gt;(rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// simple check above operators work.</span></div>
<div class="line">static_assert(requires { <a class="code" href="structAProperty.html">AProperty&lt;int&gt;</a>() + 1; });</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">// UNCOMMENT THIS to test biProjected</span></div>
<div class="line"><span class="comment">static_assert(requires (AProperty&lt;int&gt;&amp; intProperty) {</span></div>
<div class="line"><span class="comment">    { intProperty.biProjected(aui::lambda_overloaded {</span></div>
<div class="line"><span class="comment">      [](int) -&gt; AString { return &quot;&quot;; },</span></div>
<div class="line"><span class="comment">      [](const AString&amp;) -&gt; int { return 0; },</span></div>
<div class="line"><span class="comment">    }).value() } -&gt; aui::convertible_to&lt;AString&gt;;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    { intProperty.biProjected(aui::lambda_overloaded {</span></div>
<div class="line"><span class="comment">        [](int) -&gt; AString { return &quot;&quot;; },</span></div>
<div class="line"><span class="comment">        [](const AString&amp;) -&gt; int { return 0; },</span></div>
<div class="line"><span class="comment">    }) = &quot;AString&quot; };</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    { intProperty.biProjected(aui::lambda_overloaded {</span></div>
<div class="line"><span class="comment">        [](int) -&gt; AString { return &quot;&quot;; },</span></div>
<div class="line"><span class="comment">        [](const AString&amp;) -&gt; int { return 0; },</span></div>
<div class="line"><span class="comment">    }) };</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    { intProperty.biProjected(aui::lambda_overloaded {</span></div>
<div class="line"><span class="comment">        [](int) -&gt; AString { return &quot;&quot;; },</span></div>
<div class="line"><span class="comment">        [](const AString&amp;) -&gt; int { return 0; },</span></div>
<div class="line"><span class="comment">    }).assignment() } -&gt; aui::invocable&lt;AString&gt;;</span></div>
<div class="line"><span class="comment">});</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;APropertyReadable T&gt; <span class="keyword">struct </span>fmt::formatter&lt;T&gt; {</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ParseContext&gt;</div>
<div class="line">    constexpr <span class="keyword">auto</span> parse(ParseContext&amp; ctx)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> ctx.begin();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> format(T&amp; c, format_context&amp; ctx)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> fmt::format_to(ctx.out(), <span class="stringliteral">&quot;{}&quot;</span>, *c);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassAObjectBase_html"><div class="ttname"><a href="classAObjectBase.html">AObjectBase</a></div><div class="ttdef"><b>Definition:</b> AObjectBase.h:23</div></div>
<div class="ttc" id="aclassAObject_html"><div class="ttname"><a href="classAObject.html">AObject</a></div><div class="ttdoc">A base object class.</div><div class="ttdef"><b>Definition:</b> AObject.h:39</div></div>
<div class="ttc" id="aclassASignal_html"><div class="ttname"><a href="classASignal.html">ASignal&lt; Args... &gt;</a></div></div>
<div class="ttc" id="agroup__signal__slot_html_gac622150996edd734a10f229eb381a53f"><div class="ttname"><a href="group__signal__slot.html#gac622150996edd734a10f229eb381a53f">emit</a></div><div class="ttdeci">#define emit</div><div class="ttdoc">emits the specified signal in context of this object.</div><div class="ttdef"><b>Definition:</b> AObject.h:321</div></div>
<div class="ttc" id="agroup__xml_html_ga06fdf594d32ebd9bf8a564fd832c6f28"><div class="ttname"><a href="group__xml.html#ga06fdf594d32ebd9bf8a564fd832c6f28">AXml::read</a></div><div class="ttdeci">void API_AUI_XML read(const _&lt; IInputStream &gt; &amp;is, const _&lt; IXmlDocumentVisitor &gt; &amp;visitor)</div><div class="ttdoc">Parses xml from the input stream to the IXmlDocumentVisitor.</div><div class="ttdef"><b>Definition:</b> AXml.cpp:20</div></div>
<div class="ttc" id="astructAPropertyDef_html"><div class="ttname"><a href="structAPropertyDef.html">APropertyDef</a></div><div class="ttdef"><b>Definition:</b> AProperty.h:310</div></div>
<div class="ttc" id="astructAPropertyDef_html_a1bb1a0c3941698cc8ba887e0bcd6c090"><div class="ttname"><a href="structAPropertyDef.html#a1bb1a0c3941698cc8ba887e0bcd6c090">APropertyDef::base</a></div><div class="ttdeci">const M * base</div><div class="ttdoc">AObject which this property belongs to.</div><div class="ttdef"><b>Definition:</b> AProperty.h:314</div></div>
<div class="ttc" id="astructAPropertyDef_html_a34d82d6c147b2c756e2886dbe2f8601e"><div class="ttname"><a href="structAPropertyDef.html#a34d82d6c147b2c756e2886dbe2f8601e">APropertyDef::get</a></div><div class="ttdeci">Getter get</div><div class="ttdoc">Getter. Can be pointer-to-member(function or field) or lambda.</div><div class="ttdef"><b>Definition:</b> AProperty.h:320</div></div>
<div class="ttc" id="astructAPropertyDef_html_a62ad81ffc5bf8b8aa5defb808984e0a9"><div class="ttname"><a href="structAPropertyDef.html#a62ad81ffc5bf8b8aa5defb808984e0a9">APropertyDef::set</a></div><div class="ttdeci">Setter set</div><div class="ttdoc">Setter. Can be pointer-to-member(function or field) or lambda.</div><div class="ttdef"><b>Definition:</b> AProperty.h:337</div></div>
<div class="ttc" id="astructAPropertyDef_html_a79796c83902226291120377ae6bf0b9e"><div class="ttname"><a href="structAPropertyDef.html#a79796c83902226291120377ae6bf0b9e">APropertyDef::biProjected</a></div><div class="ttdeci">auto biProjected(ProjectionRead &amp;&amp;projectionRead, ProjectionWrite &amp;&amp;projectionWrite) noexcept</div><div class="ttdoc">Makes a bidirectional projection of this property.</div><div class="ttdef"><b>Definition:</b> AProperty.h:406</div></div>
<div class="ttc" id="astructAPropertyDef_html_a876e5b8fc0f3fda02585e8265f5b9a29"><div class="ttname"><a href="structAPropertyDef.html#a876e5b8fc0f3fda02585e8265f5b9a29">APropertyDef::changed</a></div><div class="ttdeci">const emits&lt; SignalArg &gt; &amp; changed</div><div class="ttdoc">Reference to underlying signal emitting on value changes.</div><div class="ttdef"><b>Definition:</b> AProperty.h:344</div></div>
<div class="ttc" id="astructAPropertyDef_html_ae6180044dbbbcfb59a4abb797b4f3f24"><div class="ttname"><a href="structAPropertyDef.html#ae6180044dbbbcfb59a4abb797b4f3f24">APropertyDef::readProjected</a></div><div class="ttdeci">auto readProjected(Projection &amp;&amp;projection) noexcept</div><div class="ttdoc">Makes a readonly projection of this property.</div><div class="ttdef"><b>Definition:</b> AProperty.h:395</div></div>
<div class="ttc" id="astructAProperty_html_ac532f4a4f88a531c28b8b289d8d93c28"><div class="ttname"><a href="structAProperty.html#ac532f4a4f88a531c28b8b289d8d93c28">AProperty::readProjected</a></div><div class="ttdeci">auto readProjected(Projection &amp;&amp;projection) noexcept</div><div class="ttdoc">Makes a readonly projection of this property.</div><div class="ttdef"><b>Definition:</b> AProperty.h:226</div></div>
<div class="ttc" id="astructAProperty_html_ae2562922cd46888709005f8aa0a6bead"><div class="ttname"><a href="structAProperty.html#ae2562922cd46888709005f8aa0a6bead">AProperty::biProjected</a></div><div class="ttdeci">auto biProjected(ProjectionRead &amp;&amp;projectionRead, ProjectionWrite &amp;&amp;projectionWrite) noexcept</div><div class="ttdoc">Makes a bidirectional projection of this property.</div><div class="ttdef"><b>Definition:</b> AProperty.h:236</div></div>
<div class="ttc" id="astructASlotDef_html"><div class="ttname"><a href="structASlotDef.html">ASlotDef</a></div><div class="ttdef"><b>Definition:</b> concepts.h:188</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
