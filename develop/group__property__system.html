<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AUI Framework: Property System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doxygen.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AUI Framework
   &#160;<span id="projectnumber">develop</span>
   </div>
   <div id="projectbrief">Cross-platform module-based framework for developing  C++20 desktop applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__property__system.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Property System<div class="ingroups"><a class="el" href="group__core.html">aui::core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Property System is a data binding mechanism based on <a class="el" href="group__signal__slot.html">signal-slot system</a>. </p>
<p>AUI property system, a compiler-agnostic alternative to __property or [property]. Based on <a class="el" href="group__signal__slot.html">signal-slot system</a> for platform-independent C++ development. Unlike Qt, AUI's properties don't involve external tools (like <code>moc</code>). They are written in pure C++.</p>
<p>AUI property system is relatively complex, as it involves a lot of features in a single place:</p><ol type="1">
<li>thread safe</li>
<li>many-to-many relationships between objects</li>
<li>optional data modification when passing values between objects (like STL projections)</li>
<li>emitter can be either signal or property</li>
<li>slot can be either lambda, method or property</li>
<li>for the latter case, system must set up backward connection as well (including projection support)</li>
<li>again, for the latter case, there's an option to make property-to-slot connection, where the "slot" is property's assignment operation</li>
<li>2 syntax variants: procedural (straightforward) and declarative</li>
<li>three property variants: simple field (<a class="el" href="structAProperty.html">AProperty</a>), custom getter/setter (<a class="el" href="structAPropertyDef.html">APropertyDef</a>) and custom evaluation (<a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a>)</li>
<li>some properties can be readonly</li>
<li>propagating strong types' traits on views</li>
</ol>
<p>Learning curve is relatively flat, so be sure to <a href="https://github.com/aui-framework/aui/issues">ask questions and open issues</a> on our GitHub page.</p>
<p>Main difference between basic value lying somewhere inside your class and a property is that the latter explicitly ties getter, setter and a signal reporting value changes. Property acts almost transparently, as if there's no extra wrapper around your data. This allows to work with properties in the same way as with their underlying values. You can read the intermediate value of a property and subscribe to its changes via a single <code>connect</code> call. Also, when connecting property to property, it is possible to make them observe changes of each other bia <code>biConnect</code> call: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">&quot;Robert&quot;</span> });</div>
<div class="line"><span class="keyword">auto</span> tf = _new&lt;ATextField&gt;();</div>
<div class="line"><a class="code" href="group__property__system.html#ga0c76a7210b013192927851449a923992">AObject::biConnect</a>(user-&gt;name, tf-&gt;text());</div>
<div class="line"><span class="keyword">auto</span> window = _new&lt;AWindow&gt;();</div>
<div class="line">window-&gt;setContents(<a class="code" href="structaui_1_1ui__building_1_1layouted__container__factory.html">Centered</a> { tf });</div>
<div class="line">window-&gt;show();</div>
<div class="ttc" id="agroup__property__system_html_ga0c76a7210b013192927851449a923992"><div class="ttname"><a href="group__property__system.html#ga0c76a7210b013192927851449a923992">AObject::biConnect</a></div><div class="ttdeci">static void biConnect(PropertySource &amp;&amp;propertySource, PropertyDestination &amp;&amp;propertyDestination) requires requires</div><div class="ttdoc">Connects source property to the destination property and opposite (bidirectionally).</div><div class="ttdef"><b>Definition:</b> AObject.h:137</div></div>
<div class="ttc" id="astructAProperty_html"><div class="ttname"><a href="structAProperty.html">AProperty</a></div><div class="ttdef"><b>Definition:</b> AProperty.h:157</div></div>
<div class="ttc" id="astructaui_1_1ptr_html_a9696eab52bd0745688055a301d9ef776"><div class="ttname"><a href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a></div><div class="ttdeci">static _&lt; T &gt; manage(T *raw)</div><div class="ttdoc">Delegates memory management of the raw pointer T* raw to the shared pointer, which is returned.</div><div class="ttdef"><b>Definition:</b> SharedPtrTypes.h:372</div></div>
<div class="ttc" id="astructaui_1_1ui__building_1_1layouted__container__factory_html"><div class="ttname"><a href="structaui_1_1ui__building_1_1layouted__container__factory.html">aui::ui_building::layouted_container_factory</a></div><div class="ttdef"><b>Definition:</b> Declarative.h:187</div></div>
</div><!-- fragment --><p>Or simpler: </p><div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line">window-&gt;setContents(<a class="code" href="structaui_1_1ui__building_1_1layouted__container__factory.html">Centered</a> {</div>
<div class="line">  tf &amp;&amp; user-&gt;name,</div>
<div class="line">});</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>The code above generates a window with a text field: <img src="imgs/UIDataBindingTest.TextField1_1.png" alt="text field" class="inline"/></p>
<p>A single call of <code>biConnect</code>:</p>
<ul>
<li>Prefills text field with the current <code>user-&gt;name</code> value (pre fire): <div class="fragment"><div class="line">EXPECT_EQ(tf-&gt;text(), <span class="stringliteral">&quot;Robert&quot;</span>);</div>
</div><!-- fragment --></li>
<li>Connects <code>user-&gt;named.changed</code> to <code>tf</code> to notify the text field about changes of <code>user-&gt;name</code>: <div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Angela&quot;</span>;           <span class="comment">// changing user-&gt;name programmatically...</span></div>
<div class="line">EXPECT_EQ(tf-&gt;text(), <span class="stringliteral">&quot;Angela&quot;</span>); <span class="comment">// ...should reflect on the text field</span></div>
</div><!-- fragment --></li>
</ul>
<p><img src="imgs/UIDataBindingTest.TextField1_2.png" alt="text field" class="inline"/></p><ul>
<li>Connects <code>tf-&gt;text().changed</code> to notify the <code>user-&gt;name</code> property about changes in text field (i.e., if the user typed another value to the text field): <img src="imgs/UIDataBindingTest.TextField1_3.png" alt="text field" class="inline"/> <div class="fragment"><div class="line"><span class="comment">// user typed &quot;Snezhana&quot;, now let&#39;s check the value in user-&gt;name:</span></div>
<div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">&quot;Snezhana&quot;</span>);</div>
</div><!-- fragment --></li>
</ul>
<p>This is basic example of setting up property-to-property connection. ALogger::info("LogObserver") &lt;&lt; "Received value: " &lt;&lt; msg;</p>
<h1><a class="anchor" id="autotoc_md147"></a>
Declaring Properties</h1>
<p>There are three ways to define a property in AUI:</p>
<h2><a class="anchor" id="AProperty"></a>
AProperty</h2>
<p>To declare a property inside your data model, use <a class="el" href="structAProperty.html">AProperty</a> template: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> surname;</div>
<div class="line">};</div>
</div><!-- fragment --><p><code><a class="el" href="structAProperty.html">AProperty</a>&lt;T&gt;</code> is a container holding an instance of <code>T</code>. You can assign a value to it with <code>operator=</code> and read value with <code>value()</code> method or implicit conversion <code>operator T()</code>. <a class="el" href="structAProperty.html">AProperty</a> behaves like a class/struct data member: </p><div class="fragment"><div class="line">User u;</div>
<div class="line">u.name = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">EXPECT_EQ(u.name, <span class="stringliteral">&quot;Hello&quot;</span>);</div>
</div><!-- fragment --><p>You can even perform binary operations on it seamlessly: </p><div class="fragment"><div class="line">User u;</div>
<div class="line">u.name = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">u.name += <span class="stringliteral">&quot; world!&quot;</span>;</div>
<div class="line">EXPECT_EQ(u.name, <span class="stringliteral">&quot;Hello world!&quot;</span>);</div>
<div class="line">EXPECT_EQ(u.name-&gt;length(), <a class="code" href="classAString.html">AString</a>(<span class="stringliteral">&quot;Hello world!&quot;</span>).length());</div>
<div class="ttc" id="aclassAString_html"><div class="ttname"><a href="classAString.html">AString</a></div><div class="ttdoc">Represents a Unicode character string.</div><div class="ttdef"><b>Definition:</b> AString.h:37</div></div>
</div><!-- fragment --><p>In most cases, property is implicitly convertible to its underlying type: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> doSomethingWithName = [](<span class="keyword">const</span> <a class="code" href="classAString.html">AString</a>&amp; name) { EXPECT_EQ(name, <span class="stringliteral">&quot;Hello&quot;</span>); };</div>
<div class="line">User u;</div>
<div class="line">u.name = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">doSomethingWithName(u.name);</div>
</div><!-- fragment --><p>If it doesn't, simply put an asterisk: </p><div class="fragment"><div class="line">doSomethingWithName(*u.name);</div>
<div class="line"><span class="comment">//                 ^^^ HERE</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md148"></a>
Observing changes</h3>
<p>All property types offer <code>.changed</code> field which is a signal reporting value changes. Let's make little observer object for demonstration: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classLogObserver.html">LogObserver</a> : <span class="keyword">public</span> <a class="code" href="classAObject.html">AObject</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> log(<span class="keyword">const</span> <a class="code" href="classAString.html">AString</a>&amp; msg) {</div>
<div class="line">        ALogger::info(<span class="stringliteral">&quot;LogObserver&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Received value: &quot;</span> &lt;&lt; msg;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassAObject_html"><div class="ttname"><a href="classAObject.html">AObject</a></div><div class="ttdoc">A base object class.</div><div class="ttdef"><b>Definition:</b> AObject.h:39</div></div>
<div class="ttc" id="aclassLogObserver_html"><div class="ttname"><a href="classLogObserver.html">LogObserver</a></div><div class="ttdef"><b>Definition:</b> UIDataBindingTest.cpp:128</div></div>
</div><!-- fragment --><p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> observer = _new&lt;LogObserver&gt;();</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">&quot;Chloe&quot;</span> });</div>
<div class="line">AObject::connect(u-&gt;name.changed, <a class="code" href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a>(observer)::log);</div>
<div class="ttc" id="agroup__signal__slot_html_gaaaa072876366972108aef016e7882a99"><div class="ttname"><a href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a></div><div class="ttdeci">#define slot(v)</div><div class="ttdoc">Passes some variable and type of the variable separated by comma. It's convenient to use with the con...</div><div class="ttdef"><b>Definition:</b> kAUI.h:90</div></div>
</div><!-- fragment --><p>At the moment, the program prints nothing. When we change the property: </p><div class="fragment"><div class="line">u-&gt;name = <span class="stringliteral">&quot;Marinette&quot;</span>;</div>
</div><!-- fragment --><p>Code produces the following output: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Marinette</div>
</div><!-- fragment --><p>As you can see, observer received the update. But, for example, if we would like to display the value via label, the label wouldn't display the current value until the next update. We want the label to display <em>current</em> value without requiring an update. To do this, connect to the property directly, without explicitly asking for <code>changed</code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> observer = _new&lt;LogObserver&gt;();</div>
<div class="line"><span class="keyword">auto</span> u = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">&quot;Chloe&quot;</span> });</div>
<div class="line">AObject::connect(u-&gt;name, <a class="code" href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a>(observer)::log);</div>
</div><!-- fragment --><p>Code above produces the following output: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Chloe</div>
</div><!-- fragment --><p> As you can see, observer receives the value without making updates to the value. The call of <code>LogObserver::log</code> is made by <code>AObject::connect</code> itself. In this document, we will call this behaviour as "pre-fire".</p>
<p>Subsequent changes to field would send updates as well: </p><div class="fragment"><div class="line">u-&gt;name = <span class="stringliteral">&quot;Marinette&quot;</span>;</div>
</div><!-- fragment --><p>Assignment operation above makes an additional line to output: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Marinette</div>
</div><!-- fragment --><p>Whole program output when connecting to property directly: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Chloe</div>
<div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Marinette</div>
</div><!-- fragment --><h2><a class="anchor" id="APropertyDef"></a>
APropertyDef</h2>
<p>You can use this way if you are required to define custom behaviour on getter/setter. As a downside, you have to write extra boilerplate code: define property, data field, signal, getter and setter checking equality. Also, <a class="el" href="structAPropertyDef.html">APropertyDef</a> requires the class to derive <code><a class="el" href="classAObject.html" title="A base object class.">AObject</a></code>. Most of <a class="el" href="classAView.html" title="Base class of all UI objects.">AView</a>'s properties are defined this way.</p>
<p>To declare a property with custom getter/setter, use <a class="el" href="structAPropertyDef.html">APropertyDef</a> template. APropertyDef-based property is defined by const member function as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>User: <span class="keyword">public</span> <a class="code" href="classAObject.html">AObject</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">auto</span> name()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structAPropertyDef.html">APropertyDef</a> {</div>
<div class="line">            <span class="keyword">this</span>,</div>
<div class="line">            &amp;User::getName, <span class="comment">// this works too: &amp;User::mName</span></div>
<div class="line">            &amp;User::setName,</div>
<div class="line">            mNameChanged,</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classAString.html">AString</a> mName;</div>
<div class="line">    <a class="code" href="classASignal.html">emits&lt;AString&gt;</a> mNameChanged;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setName(<a class="code" href="classAString.html">AString</a> name) {</div>
<div class="line">        <span class="comment">// APropertyDef requires us to emit</span></div>
<div class="line">        <span class="comment">// changed signal if value is actually</span></div>
<div class="line">        <span class="comment">// changed</span></div>
<div class="line">        <span class="keywordflow">if</span> (mName == name) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        mName = std::move(name);</div>
<div class="line">        <a class="code" href="group__signal__slot.html#gac622150996edd734a10f229eb381a53f">emit</a> mNameChanged(mName);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classAString.html">AString</a>&amp; getName()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> mName;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassASignal_html"><div class="ttname"><a href="classASignal.html">ASignal&lt; Args... &gt;</a></div></div>
<div class="ttc" id="agroup__signal__slot_html_gac622150996edd734a10f229eb381a53f"><div class="ttname"><a href="group__signal__slot.html#gac622150996edd734a10f229eb381a53f">emit</a></div><div class="ttdeci">#define emit</div><div class="ttdoc">emits the specified signal in context of this object.</div><div class="ttdef"><b>Definition:</b> AObject.h:321</div></div>
<div class="ttc" id="astructAPropertyDef_html"><div class="ttname"><a href="structAPropertyDef.html">APropertyDef</a></div><div class="ttdef"><b>Definition:</b> AProperty.h:310</div></div>
</div><!-- fragment --><p><a class="el" href="structAPropertyDef.html">APropertyDef</a> behaves like a class/struct function member: </p><div class="fragment"><div class="line">User u;</div>
<div class="line">u.name() = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">EXPECT_EQ(u.name(), <span class="stringliteral">&quot;Hello&quot;</span>);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Properties defined with <a class="el" href="structAPropertyDef.html">APropertyDef</a> instead of <a class="el" href="structAProperty.html">AProperty</a> impersonate themselves by trailing braces <code>()</code>. We can't get rid of them, as <a class="el" href="structAPropertyDef.html">APropertyDef</a> is defined thanks to member function. In comparison to <code>user-&gt;name</code>, think of <code>user-&gt;name()</code> as the same kind of property except defining custom behaviour via function, hence the braces <code>()</code>.</dd></dl>
<p>For the rest, <a class="el" href="structAPropertyDef.html">APropertyDef</a> is identical to <a class="el" href="structAProperty.html">AProperty</a> including seamless interaction: </p><div class="fragment"><div class="line">User u;</div>
<div class="line">u.name() = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">u.name() += <span class="stringliteral">&quot; world!&quot;</span>;</div>
<div class="line">EXPECT_EQ(u.name(), <span class="stringliteral">&quot;Hello world!&quot;</span>);</div>
<div class="line">EXPECT_EQ(u.name()-&gt;length(), <a class="code" href="classAString.html">AString</a>(<span class="stringliteral">&quot;Hello world!&quot;</span>).length());</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In order to honor getters/setters, <code><a class="el" href="structAPropertyDef.html">APropertyDef</a></code> calls getter/setter instead of using <code>+=</code> on your property directly. Equivalent code will be: <div class="fragment"><div class="line">u.setName(u.getName() + <span class="stringliteral">&quot; world!&quot;</span>)</div>
</div><!-- fragment --></dd></dl>
<p>The implicit conversions work the same way as with <a class="el" href="structAProperty.html">AProperty</a>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> doSomethingWithName = [](<span class="keyword">const</span> <a class="code" href="classAString.html">AString</a>&amp; name) { EXPECT_EQ(name, <span class="stringliteral">&quot;Hello&quot;</span>); };</div>
<div class="line">User u;</div>
<div class="line">u.name() = <span class="stringliteral">&quot;Hello&quot;</span>;</div>
<div class="line">doSomethingWithName(u.name());</div>
</div><!-- fragment --><div class="fragment"><div class="line">doSomethingWithName(*u.name());</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md149"></a>
Observing changes</h3>
<p>Close to <code><a class="el" href="structAProperty.html">AProperty</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> observer = _new&lt;LogObserver&gt;();</div>
<div class="line"><span class="keyword">auto</span> u = _new&lt;User&gt;();</div>
<div class="line">u-&gt;name() = <span class="stringliteral">&quot;Chloe&quot;</span>;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">AObject::connect(u-&gt;name().changed, <a class="code" href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a>(observer)::log);</div>
</div><!-- fragment --><div class="fragment"><div class="line">u-&gt;name() = <span class="stringliteral">&quot;Marinette&quot;</span>;</div>
</div><!-- fragment --><p>Code produces the following output: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Marinette</div>
</div><!-- fragment --><p>Making connection to property directly instead of <code>.changed</code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> observer = _new&lt;LogObserver&gt;();</div>
<div class="line"><span class="keyword">auto</span> u = _new&lt;User&gt;();</div>
<div class="line">u-&gt;name() = <span class="stringliteral">&quot;Chloe&quot;</span>;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">AObject::connect(u-&gt;name(), <a class="code" href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a>(observer)::log);</div>
</div><!-- fragment --><p>Code above produces the following output: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Chloe</div>
</div><!-- fragment --><p>Subsequent changes to field would send updates as well: </p><div class="fragment"><div class="line">u-&gt;name() = <span class="stringliteral">&quot;Marinette&quot;</span>;</div>
</div><!-- fragment --><p>Assignment operation above makes an additional line to output: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Marinette</div>
</div><!-- fragment --><p>Whole program output when connecting to property directly: </p><div class="fragment"><div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Chloe</div>
<div class="line">[07:58:59][][<a class="code" href="classLogObserver.html">LogObserver</a>][INFO]: Received value: Marinette</div>
</div><!-- fragment --><h2><a class="anchor" id="APropertyPrecomputed"></a>
APropertyPrecomputed</h2>
<p>Despite properties offer <a class="el" href="group__property__system.html#Label_via_declarative_projection">projection methods</a>, you might want to track and process values of several properties.</p>
<p><code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a>&lt;T&gt;</code> is a readonly property similar to <code><a class="el" href="structAProperty.html">AProperty</a>&lt;T&gt;</code>. It holds an instance of <code>T</code> as well. Its value is determined by the C++ function specified in its constructor, typically a C++ lambda expression.</p>
<p>It's convenient to access values from another properties inside the expression. The properties accessed during invocation of the expression are tracked behind the scenes so they become dependencies of <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> automatically. If one of the tracked properties fires <code>changed</code> signal, <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> invalidates its <code>T</code>. <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> follows <a class="el" href="structaui_1_1lazy.html">lazy semantics</a> so the expression is re-evaluated and the new result is applied to <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> as soon as the latter is accessed for the next time.</p>
<p>In other words, it allows to specify relationships between different object properties and reactively update <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> value whenever its dependencies change. <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a>&lt;T&gt;</code> is somewhat similar to <a href="https://doc.qt.io/qt-6/bindableproperties.html">Qt Bindable Properties</a>.</p>
<p><code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> is a readonly property, hence you can't update its value with assignment. You can get its value with <code>value()</code> method or implicit conversion <code>operator T()</code> as with other properties.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> surname;</div>
<div class="line">    <a class="code" href="structAPropertyPrecomputed.html">APropertyPrecomputed&lt;AString&gt;</a> fullName = [&amp;] { <span class="keywordflow">return</span> <span class="stringliteral">&quot;{} {}&quot;</span>_format(name, surname); };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> u = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User {</div>
<div class="line">    .name = <span class="stringliteral">&quot;Emma&quot;</span>,</div>
<div class="line">    .surname = <span class="stringliteral">&quot;Watson&quot;</span>,</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> observer = _new&lt;LogObserver&gt;();</div>
<div class="line">AObject::connect(u-&gt;fullName, <a class="code" href="group__signal__slot.html#gaaaa072876366972108aef016e7882a99">slot</a>(observer)::log);</div>
<div class="ttc" id="astructAPropertyPrecomputed_html"><div class="ttname"><a href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></div><div class="ttdef"><b>Definition:</b> APropertyPrecomputed.h:64</div></div>
</div><!-- fragment --><p>The example above prints "Emma Watson". If we try to update one of dependencies of <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> (i.e., <code>name</code> or <code>surname</code>), <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> responds immediately: </p><div class="fragment"><div class="line">u-&gt;surname = <span class="stringliteral">&quot;Stone&quot;</span>;</div>
</div><!-- fragment --><p>The example above prints "Emma Stone".</p>
<h3><a class="anchor" id="autotoc_md150"></a>
Observing changes</h3>
<p>Similar to <code><a class="el" href="structAProperty.html">AProperty</a></code>.</p>
<h3><a class="anchor" id="autotoc_md151"></a>
Valid Expressions</h3>
<p>Any C++ callable evaluating to <code>T</code> can be used as an expression for <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a>&lt;T&gt;</code>. However, to formulate correct expression, some rules must be satisfied.</p>
<p>Dependency tracking only works on other properties. It is the developer's responsibility to ensure all values referenced in the expression are properties, or, at least, non-property values that wouldn't change or whose changes are not interesting. You definitely can use branching inside the expression, but you must be confident about what are you doing. Generally speaking, use as trivial expressions as possible.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> surname;</div>
<div class="line">    <a class="code" href="structAPropertyPrecomputed.html">APropertyPrecomputed&lt;AString&gt;</a> fullName = [&amp;]() -&gt; <a class="code" href="classAString.html">AString</a> {</div>
<div class="line">        <span class="keywordflow">if</span> (name-&gt;empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (surname-&gt;empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;{} {}&quot;</span>_format(name, surname);</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p>In this expression, we have a fast path return if <code>name</code> is empty. </p><div class="fragment"><div class="line">User u = {</div>
<div class="line">    .name = <span class="stringliteral">&quot;Emma&quot;</span>,</div>
<div class="line">    .surname = <span class="stringliteral">&quot;Watson&quot;</span>,</div>
<div class="line">};</div>
<div class="line"><span class="comment">// trivial: we&#39;ve accessed all referenced properties</span></div>
<div class="line">EXPECT_EQ(u.fullName, <span class="stringliteral">&quot;Emma Watson&quot;</span>);</div>
</div><!-- fragment --><p>As soon as we set <code>name</code> to <code>""</code>, we don't access <code>surname</code>. If we try to trigger the fast path return: </p><div class="fragment"><div class="line">u.name = <span class="stringliteral">&quot;&quot;</span>;</div>
</div><!-- fragment --><p><code>surname</code> can't trigger re-evaluation anyhow. Re-evaluation can be triggered by <code>name</code> only. So, at the moment, we are interested in <code>name</code> changes only.</p>
<p><code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code> might evaluate its expression several times during its lifetime. The developer must make sure that all objects referenced in the expression live longer than <code><a class="el" href="structAPropertyPrecomputed.html">APropertyPrecomputed</a></code>.</p>
<p>The expression should not read from the property it's a binding for. Otherwise, there's an infinite evaluation loop. </p>
<h1><a class="anchor" id="autotoc_md152"></a>
UI data binding with let</h1>
<dl class="section note"><dt>Note</dt><dd>This is a comprehensive, straightforward way of setting up a connection. We are demonstrating it here so you can get deeper understanding on how connections are made and what does declarative way do under the hood. This way may be used in favour of declarative way if the latter not work for you. For declarative way, go to "UI_declarative_data_binding".</dd></dl>
<p>This approach allows more control over the binding process by using <code>AObject::connect</code>/<code><a class="el" href="group__property__system.html#ga0c76a7210b013192927851449a923992" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> which is a procedural way of setting up connections. As a downside, it requires "let" syntax clause which may seem as overkill for such a simple operation.</p>
<h2><a class="anchor" id="Label_via_let"></a>
Label via let</h2>
<p>Use <code>let</code> expression to connect the model's username property to the label's <a class="el" href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">text()</a> property. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>declarative;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">&quot;Roza&quot;</span> });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classMyWindow.html">MyWindow</a>: <span class="keyword">public</span> <a class="code" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classMyWindow.html">MyWindow</a>(<span class="keyword">const</span> <a class="code" href="class__.html">_&lt;User&gt;</a>&amp; user) {</div>
<div class="line">        setContents(<a class="code" href="structaui_1_1ui__building_1_1layouted__container__factory.html">Centered</a> {</div>
<div class="line">            _new&lt;ALabel&gt;() <a class="code" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">              <span class="comment">// Data goes from left to right:</span></div>
<div class="line">              <span class="comment">// current value (pre fire) or changed event</span></div>
<div class="line">              <span class="comment">// goes to assignment operation of it-&gt;text()</span></div>
<div class="line">              AObject::connect(user-&gt;name, it-&gt;text());</div>
<div class="line">              <span class="comment">//                -&gt;  -&gt;  -&gt;  -&gt;  -&gt;</span></div>
<div class="line">              <span class="comment">// in other words, this connection is essentially the</span></div>
<div class="line">              <span class="comment">// same as</span></div>
<div class="line">              <span class="comment">// AObject::connect(user-&gt;name, slot(it)::setText);</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// if you want user-&gt;name to be aware or it-&gt;text()</span></div>
<div class="line">              <span class="comment">// changes (i.e., if it were an editable view</span></div>
<div class="line">              <span class="comment">// like ATextField) use AObject::biConnect instead</span></div>
<div class="line">              <span class="comment">// (see &quot;Bidirectional connection&quot; sample).</span></div>
<div class="line">            },</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">_new&lt;MyWindow&gt;(user)-&gt;<a class="code" href="classAWindow.html#af7360ab4bb102de6cbdf066e9ab8348b">show</a>();</div>
<div class="ttc" id="aclassAWindow_html"><div class="ttname"><a href="classAWindow.html">AWindow</a></div><div class="ttdoc">Represents a window in the underlying windowing system.</div><div class="ttdef"><b>Definition:</b> AWindow.h:45</div></div>
<div class="ttc" id="aclassAWindow_html_af7360ab4bb102de6cbdf066e9ab8348b"><div class="ttname"><a href="classAWindow.html#af7360ab4bb102de6cbdf066e9ab8348b">AWindow::show</a></div><div class="ttdeci">void show()</div><div class="ttdef"><b>Definition:</b> AWindowsImpl.cpp:126</div></div>
<div class="ttc" id="aclassMyWindow_html"><div class="ttname"><a href="classMyWindow.html">MyWindow</a></div><div class="ttdef"><b>Definition:</b> UIDataBindingTest.cpp:807</div></div>
<div class="ttc" id="aclass___html"><div class="ttname"><a href="class__.html">_</a></div><div class="ttdoc">An std::weak_ptr with AUI extensions.</div><div class="ttdef"><b>Definition:</b> SharedPtrTypes.h:178</div></div>
<div class="ttc" id="agroup__useful__macros_html_ga045dd54932944d8830380f4596d64446"><div class="ttname"><a href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a></div><div class="ttdeci">#define let</div><div class="ttdoc">Performs multiple operations on a single object without repeating its name (in place) This function c...</div><div class="ttdef"><b>Definition:</b> kAUI.h:262</div></div>
</div><!-- fragment --><p>This gives the following result: <img src="imgs/UIDataBindingTest.Label_via_declarative_1.png" alt="text" class="inline"/> Note that label already displays the value stored in <a class="el" href="structUser.html">User</a>.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Vasil&quot;</span>;</div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Label_via_declarative_2.png" alt="text" class="inline"/></p>
<p><a class="el" href="namespaceBy.html" title="Matcher factory namespace.">By</a> simply performing assignment on <code>user</code> we changed <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> display text. Magic, huh?</p>
<h2><a class="anchor" id="Label_via_let_projection"></a>
Label via let projection</h2>
<p>It's fairly easy to define a projection because one-sided connection requires exactly one projection, obviously. </p><div class="fragment"><div class="line">_new&lt;ALabel&gt;() <a class="code" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">    <span class="comment">// Data goes from left to right:</span></div>
<div class="line">    <span class="comment">// current value (pre fire) or changed event</span></div>
<div class="line">    <span class="comment">// goes through projection (&amp;AString::uppercase) first</span></div>
<div class="line">    <span class="comment">// then it goes to assignment operation of it-&gt;text()</span></div>
<div class="line">    <span class="comment">// property.</span></div>
<div class="line">    AObject::connect(user-&gt;name.readProjected(&amp;AString::uppercase), it-&gt;text());</div>
<div class="line">    <span class="comment">//                -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;  -&gt;</span></div>
<div class="line">    <span class="comment">// in other words, this connection is essentially the same as</span></div>
<div class="line">    <span class="comment">// AObject::connect(user-&gt;name.projected(&amp;AString::uppercase), slot(it)::setText);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if view&#39;s property gets changed (i.e., by user or by occasional</span></div>
<div class="line">    <span class="comment">// ALabel::setText), these changes DO NOT reflect on model</span></div>
<div class="line">    <span class="comment">// as we requested connect() here instead of biConnect().</span></div>
<div class="line">},</div>
</div><!-- fragment --><p>This gives the following result: <img src="imgs/UIDataBindingTest.Label_via_declarative_projection_1.png" alt="text" class="inline"/> Note that the label already displays the <b>projected</b> value stored in <a class="el" href="structUser.html">User</a>.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Vasil&quot;</span>;</div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Label_via_declarative_projection_2.png" alt="text" class="inline"/></p>
<p>This way, we've set up data binding with projection.</p>
<h2><a class="anchor" id="Bidirectional_connection"></a>
Bidirectional connection</h2>
<p>In previous examples, we've used <code>AObject::connect</code> to make one directional (one sided) connection. This is perfectly enough for <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> because it cannot be changed by user.</p>
<p>In some cases, you might want to use property-to-property as it's bidirectional. It's used for populating view from model and obtaining data from view back to the model.</p>
<p>For this example, let's use <a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> instead of <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> as it's an editable view. In this case, we'd want to use <code><a class="el" href="group__property__system.html#ga0c76a7210b013192927851449a923992" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> because we do want <code>user-&gt;name</code> to be aware of changes of the view. </p><div class="fragment"><div class="line">_new&lt;ATextField&gt;() <a class="code" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">  <span class="comment">// Data goes from left to right in the first place</span></div>
<div class="line">  <span class="comment">// (i.e., user-&gt;name current value overrides it-&gt;text())</span></div>
<div class="line">  <span class="comment">// if view&#39;s property gets changed (i.e., by user),</span></div>
<div class="line">  <span class="comment">// these changes reflect on model</span></div>
<div class="line">  <span class="comment">// as we requested biConnect here</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//                -&gt; value + changes -&gt;</span></div>
<div class="line">  <a class="code" href="group__property__system.html#ga0c76a7210b013192927851449a923992">AObject::biConnect</a>(user-&gt;name, it-&gt;text());</div>
<div class="line">  <span class="comment">//                &lt;-  changes only   &lt;-</span></div>
<div class="line">},</div>
</div><!-- fragment --><p>This gives the following result: <img src="imgs/UIDataBindingTest.Declarative_bidirectional_connection_1.png" alt="text" class="inline"/></p>
<p>Let's change the name programmatically: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Vasil&quot;</span>;</div>
</div><!-- fragment --><p><a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> will respond: <img src="imgs/UIDataBindingTest.Declarative_bidirectional_connection_2.png" alt="text" class="inline"/></p>
<p>If the user changes the value from UI, these changes will reflect on <code>user-&gt;model</code> as well: <img src="imgs/UIDataBindingTest.Declarative_bidirectional_connection_3.png" alt="text" class="inline"/> </p><div class="fragment"><div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">&quot;Changed from UI&quot;</span>);</div>
</div><!-- fragment --><p>This way we've set up bidirectional projection via <code><a class="el" href="group__property__system.html#ga0c76a7210b013192927851449a923992" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> which makes <code>user-&gt;name</code> aware of UI changes.</p>
<h2><a class="anchor" id="Bidirectional_projection"></a>
Bidirectional projection</h2>
<p>Bidirectional connection updates values in both directions, hence it requires the projection to work in both sides as well.</p>
<p>It is the case for <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> with enums. <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> works with string list model and indices. It does not know anything about underlying values.</p>
<p>For example, define enum with <a class="el" href="group__views.html#gaa3a1ee4ac89b676d1ce135f06e49c16a">AUI_ENUM_VALUES</a> and model:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Gender {</div>
<div class="line">    MALE,</div>
<div class="line">    FEMALE,</div>
<div class="line">    OTHER,</div>
<div class="line">};</div>
<div class="line"><a class="code" href="group__views.html#gaa3a1ee4ac89b676d1ce135f06e49c16a">AUI_ENUM_VALUES</a>(Gender,</div>
<div class="line">                Gender::MALE,</div>
<div class="line">                Gender::FEMALE,</div>
<div class="line">                Gender::OTHER)</div>
<div class="ttc" id="agroup__views_html_gaa3a1ee4ac89b676d1ce135f06e49c16a"><div class="ttname"><a href="group__views.html#gaa3a1ee4ac89b676d1ce135f06e49c16a">AUI_ENUM_VALUES</a></div><div class="ttdeci">AUI_ENUM_VALUES(ATextOverflow, ATextOverflow::ELLIPSIS, ATextOverflow::CLIP) enum class AOverflowMask</div><div class="ttdoc">Controls the behaviour of the default AView::drawStencilMask() implementation.</div><div class="ttdef"><b>Definition:</b> AOverflow.h:55</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;Gender&gt;</a> gender;</div>
<div class="line">    <span class="comment">// we&#39;ve omitted other fields for sake of simplicity</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Now, let's get a mapping for our <code>Gender</code> enum: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">auto</span> GENDERS = aui::enumerate::ALL_VALUES&lt;Gender&gt;;</div>
</div><!-- fragment --><p>The compile-time constant above is equivalent to: </p><div class="fragment"><div class="line"><span class="comment">/* pseudocode */</span></div>
<div class="line">GENDERS = std::array { Gender::MALE, Gender::FEMALE, GENDER::OTHER };</div>
</div><!-- fragment --><p>We just using <code>aui::enumerate::ALL_VALUES</code> because it was provided conveniently by <code>AUI_ENUM_VALUES</code> for us.</p>
<p>It's not hard to guess that we'll use indices of this array to uniquely identify <code>Gender</code> associated with this index: </p><div class="fragment"><div class="line"><span class="comment">/* pseudocode */</span></div>
<div class="line">GENDERS[0]; <span class="comment">// -&gt; MALE</span></div>
<div class="line">GENDERS[1]; <span class="comment">// -&gt; FEMALE</span></div>
<div class="line">GENDERS[2]; <span class="comment">// -&gt; OTHER</span></div>
</div><!-- fragment --><p>To perform opposite operation (i.e., <code>Gender</code> to int), we can use <code>aui::indexOf</code>: </p><div class="fragment"><div class="line"><span class="comment">/* pseudocode */</span></div>
<div class="line"><a class="code" href="group__core.html#ga6479e06ce4827d5cd89cf85ec62612aa">aui::indexOf</a>(GENDERS, Gender::MALE);   <span class="comment">// -&gt; 0</span></div>
<div class="line"><a class="code" href="group__core.html#ga6479e06ce4827d5cd89cf85ec62612aa">aui::indexOf</a>(GENDERS, Gender::FEMALE); <span class="comment">// -&gt; 1</span></div>
<div class="line"><a class="code" href="group__core.html#ga6479e06ce4827d5cd89cf85ec62612aa">aui::indexOf</a>(GENDERS, Gender::OTHER);  <span class="comment">// -&gt; 2</span></div>
<div class="ttc" id="agroup__core_html_ga6479e06ce4827d5cd89cf85ec62612aa"><div class="ttname"><a href="group__core.html#ga6479e06ce4827d5cd89cf85ec62612aa">aui::indexOf</a></div><div class="ttdeci">AOptional&lt; size_t &gt; indexOf(const Container &amp;c, const typename Container::const_reference value) noexcept</div><div class="ttdoc">Finds the index of the first occurrence of the value.</div><div class="ttdef"><b>Definition:</b> containers.h:254</div></div>
</div><!-- fragment --><p>To bring these conversions together, let's use overloaded lambda: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">auto</span> GENDER_INDEX_PROJECTION = <a class="code" href="structaui_1_1lambda__overloaded.html">aui::lambda_overloaded</a> {</div>
<div class="line">    [](Gender g) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> <a class="code" href="group__core.html#ga6479e06ce4827d5cd89cf85ec62612aa">aui::indexOf</a>(GENDERS, g).valueOr(0); },</div>
<div class="line">    [](<span class="keywordtype">int</span> i) -&gt; Gender { <span class="keywordflow">return</span> GENDERS[i]; },</div>
<div class="line">};</div>
<div class="ttc" id="astructaui_1_1lambda__overloaded_html"><div class="ttname"><a href="structaui_1_1lambda__overloaded.html">aui::lambda_overloaded</a></div><div class="ttdef"><b>Definition:</b> callables.h:36</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It's convenient to use lambda trailing return type syntax (i.e., <code>... -&gt; int</code>, <code>... -&gt; Gender</code>) to make it obvious what do transformations do and how one type is transformed to another.</dd></dl>
<p>The function-like object above detects the direction of transformation and performs as follows: </p><div class="fragment"><div class="line">GENDER_INDEX_PROJECTION(0); <span class="comment">// -&gt; MALE</span></div>
<div class="line">GENDER_INDEX_PROJECTION(Gender::MALE); <span class="comment">// -&gt; 0</span></div>
</div><!-- fragment --><p>It is all what we need to set up bidirectional transformations. Inside AUI_ENTRY: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> user = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .gender = Gender::MALE });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classMyWindow.html">MyWindow</a>: <span class="keyword">public</span> <a class="code" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classMyWindow.html">MyWindow</a>(<span class="keyword">const</span> <a class="code" href="class__.html">_&lt;User&gt;</a>&amp; user) {</div>
<div class="line">        <span class="comment">// generate a string list model for genders from GENDERS array defined earlier</span></div>
<div class="line">        <span class="keyword">auto</span> gendersStr = <a class="code" href="classAListModel.html#acd45fc0468691fa4e585ec3ade7200b7">AListModel&lt;AString&gt;::fromVector</a>(</div>
<div class="line">            GENDERS</div>
<div class="line">            | ranges::views::transform(<a class="code" href="classAEnumerate.html">AEnumerate&lt;Gender&gt;::toName</a>)</div>
<div class="line">            | ranges::to_vector);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// equivalent:</span></div>
<div class="line">        <span class="comment">// gendersStr = { &quot;MALE&quot;, &quot;FEMALE&quot;, &quot;OTHER&quot; }</span></div>
<div class="line">        <span class="comment">// you can customize the displayed strings by playing with</span></div>
<div class="line">        <span class="comment">// ranges::views::transform argument.</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="classAViewContainer.html#ab7bcd4a4bc08fc11c9bc1a9ff036f5e4">setContents</a>(<a class="code" href="structaui_1_1ui__building_1_1layouted__container__factory.html">Centered</a> {</div>
<div class="line">          _new&lt;ADropdownList&gt;(gendersStr) <a class="code" href="group__useful__macros.html#ga045dd54932944d8830380f4596d64446">let</a> {</div>
<div class="line">              <span class="comment">// AObject::connect(user-&gt;gender, it-&gt;selectionId());</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// The code above would break, because Gender and int</span></div>
<div class="line">              <span class="comment">// (selectionId() type) are incompatible.</span></div>
<div class="line">              <span class="comment">//</span></div>
<div class="line">              <span class="comment">// Instead, define bidirectional projection:</span></div>
<div class="line">               <a class="code" href="group__property__system.html#ga0c76a7210b013192927851449a923992">AObject::biConnect</a>(</div>
<div class="line">                   user-&gt;gender.biProjected(GENDER_INDEX_PROJECTION),</div>
<div class="line">                   it-&gt;selectionId());</div>
<div class="line">              },</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">_new&lt;MyWindow&gt;(user)-&gt;show();</div>
<div class="ttc" id="aclassAEnumerate_html"><div class="ttname"><a href="classAEnumerate.html">AEnumerate</a></div><div class="ttdoc">Enum trait to transform enum to name, name to enum, list all enums and vise versa.</div><div class="ttdef"><b>Definition:</b> AEnumerate.h:79</div></div>
<div class="ttc" id="aclassAListModel_html_acd45fc0468691fa4e585ec3ade7200b7"><div class="ttname"><a href="classAListModel.html#acd45fc0468691fa4e585ec3ade7200b7">AListModel::fromVector</a></div><div class="ttdeci">static _&lt; AListModel&lt; StoredType &gt; &gt; fromVector(AVector&lt; V &gt; t)</div><div class="ttdef"><b>Definition:</b> AListModel.h:244</div></div>
<div class="ttc" id="aclassAViewContainer_html_ab7bcd4a4bc08fc11c9bc1a9ff036f5e4"><div class="ttname"><a href="classAViewContainer.html#ab7bcd4a4bc08fc11c9bc1a9ff036f5e4">AViewContainer::setContents</a></div><div class="ttdeci">void setContents(const _&lt; AViewContainer &gt; &amp;container)</div><div class="ttdoc">Moves (like via std::move) all children and layout of the specified container to this container.</div><div class="ttdef"><b>Definition:</b> AViewContainerBase.cpp:515</div></div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Declarative_bidirectional_projection_1.png" alt="dropdownlist" class="inline"/></p>
<ul>
<li>If we try to change <code>user-&gt;gender</code> programmatically, <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> will respond: <div class="fragment"><div class="line">user-&gt;gender = Gender::FEMALE;</div>
<div class="line">EXPECT_EQ(dropdownList-&gt;getSelectedId(), 1); <span class="comment">// second option</span></div>
</div><!-- fragment --></li>
</ul>
<p><img src="imgs/UIDataBindingTest.Declarative_bidirectional_projection_2.png" alt="dropdownlist" class="inline"/></p>
<ul>
<li>If the user changes the value of <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a>, it reflects on the model as well: <div class="fragment"><div class="line">EXPECT_EQ(user-&gt;gender, Gender::OTHER);</div>
</div><!-- fragment --></li>
</ul>
<p><img src="imgs/UIDataBindingTest.Declarative_bidirectional_projection_3.png" alt="dropdownlist" class="inline"/></p>
<h1><a class="anchor" id="UI_declarative_data_binding"></a>
UI declarative data binding</h1>
<p>As said earlier, <code>let</code> syntax is a little bit clunky and requires extra boilerplate code to set up.</p>
<p>Here's where declarative syntax comes into play. The logic behind the syntax is the same as in <code>AObject::connect</code>/<code><a class="el" href="group__property__system.html#ga0c76a7210b013192927851449a923992" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code> (for ease of replacement/understanding).</p>
<p>Declarative syntax uses <code>&amp;</code> and <code>&amp;&amp;</code> operators to set up connections. These were chosen intentionally: <code>&amp;&amp;</code> resembles chain, so we "chaining view and property up".</p>
<ul>
<li><code>&amp;</code> sets up one-directional connection (<code>AObject::connect</code>).</li>
<li><code>&amp;&amp;</code> sets up bidirectional connection (<code><a class="el" href="group__property__system.html#ga0c76a7210b013192927851449a923992" title="Connects source property to the destination property and opposite (bidirectionally).">AObject::biConnect</a></code>).</li>
</ul>
<p>Also, <code>&gt;</code> operator (resembles arrow) is used to specify the destination slot.</p>
<p>The example below is essentially the same as "Label_via_let" but uses declarative connection set up syntax.</p>
<h2><a class="anchor" id="Label_via_declarative"></a>
Label via declarative</h2>
<p>Use <code>&amp;</code> and <code>&gt;</code> expression to connect the model's username property to the label's <a class="el" href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">text</a> property. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>declarative;</div>
<div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">&quot;Roza&quot;</span> });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classMyWindow.html">MyWindow</a>: <span class="keyword">public</span> <a class="code" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classMyWindow.html">MyWindow</a>(<span class="keyword">const</span> <a class="code" href="class__.html">_&lt;User&gt;</a>&amp; user) {</div>
<div class="line">        setContents(<a class="code" href="structaui_1_1ui__building_1_1layouted__container__factory.html">Centered</a> {</div>
<div class="line">          _new&lt;ALabel&gt;() &amp; user-&gt;name &gt; &amp;<a class="code" href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">ALabel::text</a></div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> window = _new&lt;MyWindow&gt;(user);</div>
<div class="line">window-&gt;show();</div>
<div class="ttc" id="aclassAAbstractLabel_html_a22750596fa02b042ae73c6fcabad750d"><div class="ttname"><a href="classAAbstractLabel.html#a22750596fa02b042ae73c6fcabad750d">AAbstractLabel::text</a></div><div class="ttdeci">auto text() const</div><div class="ttdoc">Label's text property.</div><div class="ttdef"><b>Definition:</b> AAbstractLabel.h:37</div></div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Label_via_declarative_1.png" alt="text" class="inline"/> Note that the label already displays the value stored in <a class="el" href="structUser.html">User</a>.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Vasil&quot;</span>;</div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Label_via_declarative_2.png" alt="text" class="inline"/> In this example, we've achieved the same intuitive behaviour of data binding of <code>user-&gt;name</code> (like in "Label_via_let" example) but using declarative syntax. The logic behind <code>&amp;</code> is almost the same as with <code>let</code></p><ul>
<li><code>AObject::connect</code> so projection use cases can be adapted in a similar manner.</li>
</ul>
<h2><a class="anchor" id="ADataBindingDefault_for_omitting_view_property"></a>
ADataBindingDefault for omitting view property</h2>
<p>In previous example we have explicitly specified <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a>'s property to connect with.</p>
<p>One of notable features of declarative way (in comparison to procedural <code>let</code> way) is that we can omit the view's property to connect with if such <code><a class="el" href="structADataBindingDefault.html" title="Defines how View handles properties of FieldType type.">ADataBindingDefault</a></code> specialization exist for the target view and the property type. Some views have already predefined such specialization for their underlying types. For instance, <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> has such specialization:</p>
<div class="fragment"><div class="line"><span class="comment">/* PREDEFINED! You don&#39;t need to define it! This listing is an example */</span></div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structADataBindingDefault.html">ADataBindingDefault</a>&lt;<a class="code" href="classALabel.html">ALabel</a>, <a class="code" href="classAString.html">AString</a>&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> <a class="code" href="structADataBindingDefault.html#a8b84a1211f21be11840c0f38d5d69c2a">property</a>(<span class="keyword">const</span> <a class="code" href="class__.html">_&lt;ALabel&gt;</a>&amp; view) { <span class="keywordflow">return</span> view-&gt;text(); }</div>
<div class="line">};</div>
<div class="ttc" id="aclassALabel_html"><div class="ttname"><a href="classALabel.html">ALabel</a></div><div class="ttdoc">Represents a simple single-line text display view.</div><div class="ttdef"><b>Definition:</b> ALabel.h:23</div></div>
<div class="ttc" id="astructADataBindingDefault_html"><div class="ttname"><a href="structADataBindingDefault.html">ADataBindingDefault</a></div><div class="ttdoc">Defines how View handles properties of FieldType type.</div><div class="ttdef"><b>Definition:</b> ADataBinding.h:37</div></div>
<div class="ttc" id="astructADataBindingDefault_html_a8b84a1211f21be11840c0f38d5d69c2a"><div class="ttname"><a href="structADataBindingDefault.html#a8b84a1211f21be11840c0f38d5d69c2a">ADataBindingDefault::property</a></div><div class="ttdeci">static auto property(const _&lt; View &gt; &amp;view)</div><div class="ttdoc">Returns property definition for FieldType.</div><div class="ttdef"><b>Definition:</b> ADataBinding.h:49</div></div>
</div><!-- fragment --><p>We can use this predefined specialization to omit the destination property: </p><div class="fragment"><div class="line">_new&lt;ALabel&gt;() &amp; user-&gt;name</div>
</div><!-- fragment --><p>Behaviour of such connection is equal to "Label_via_declarative":</p>
<p><img src="imgs/UIDataBindingTest.Label_via_declarative_1.png" alt="text" class="inline"/> Note that the label already displays the value stored in <a class="el" href="structUser.html">User</a>.</p>
<p>Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Vasil&quot;</span>;</div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Label_via_declarative_2.png" alt="text" class="inline"/> In this example, we've omitted the destination property of the connection while maintaining the same behaviour as in "Label_via_declarative".</p>
<h2><a class="anchor" id="ADataBindingDefault_strong_type_propagation"></a>
ADataBindingDefault strong type propagation</h2>
<p>Think of <code><a class="el" href="structADataBindingDefault.html" title="Defines how View handles properties of FieldType type.">ADataBindingDefault</a></code> as we're not only connecting properties to properties, but also creating a "property to view" relationship. This philosophy covers the following scenario.</p>
<p>In AUI, there's <a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a> template which stores valid value range right inside the type: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;aui::ranged_number&lt;int, 1, 99&gt;</a>&gt; age;</div>
<div class="line">};</div>
</div><!-- fragment --><p>These strong types can be used to propagate their traits on views, i.e., <a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a>. When using declarative syntax, the property system calls <code><a class="el" href="structADataBindingDefault.html#a55e3cde07f6e2fdbdd4dc0a15451e8cf" title="Called then view linked with field.">ADataBindingDefault::setup</a></code> to apply some extra traits of the bound value on the view. Here's an abstract on how <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code> defines specialization of <code>ADataBingingDefault</code> with <code><a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a></code>: </p><div class="fragment"><div class="line"><span class="comment">/* PREDEFINED! You don&#39;t need to define it! This listing is an example */</span></div>
<div class="line"><span class="keyword">template</span> &lt;aui::arithmetic UnderlyingType, auto min, auto max&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structADataBindingDefault.html">ADataBindingDefault</a>&lt;<a class="code" href="classANumberPicker.html">ANumberPicker</a>, aui::ranged_number&lt;UnderlyingType, min, max&gt;&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> <a class="code" href="structADataBindingDefault.html#a8b84a1211f21be11840c0f38d5d69c2a">property</a>(<span class="keyword">const</span> <a class="code" href="class__.html">_&lt;ANumberPicker&gt;</a>&amp; view) {</div>
<div class="line">        <span class="keywordflow">return</span> view-&gt;value();</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structADataBindingDefault.html#a55e3cde07f6e2fdbdd4dc0a15451e8cf">setup</a>(<span class="keyword">const</span> <a class="code" href="class__.html">_&lt;ANumberPicker&gt;</a>&amp; view) {</div>
<div class="line">        view-&gt;setMin(<a class="code" href="structaui_1_1ranged__number.html">aui::ranged_number&lt;UnderlyingType, min, max&gt;::MIN</a>);</div>
<div class="line">        view-&gt;setMax(<a class="code" href="structaui_1_1ranged__number.html">aui::ranged_number&lt;UnderlyingType, min, max&gt;::MAX</a>);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassANumberPicker_html"><div class="ttname"><a href="classANumberPicker.html">ANumberPicker</a></div><div class="ttdoc">A text field for numbers with increase/decrease buttons.</div><div class="ttdef"><b>Definition:</b> ANumberPicker.h:24</div></div>
<div class="ttc" id="astructADataBindingDefault_html_a55e3cde07f6e2fdbdd4dc0a15451e8cf"><div class="ttname"><a href="structADataBindingDefault.html#a55e3cde07f6e2fdbdd4dc0a15451e8cf">ADataBindingDefault::setup</a></div><div class="ttdeci">static void setup(const _&lt; View &gt; &amp;view)</div><div class="ttdoc">Called then view linked with field.</div><div class="ttdef"><b>Definition:</b> ADataBinding.h:43</div></div>
<div class="ttc" id="astructaui_1_1ranged__number_html"><div class="ttname"><a href="structaui_1_1ranged__number.html">aui::ranged_number</a></div><div class="ttdoc">Clamps the possible values for a number to the specified range: [min;max].</div><div class="ttdef"><b>Definition:</b> values.h:456</div></div>
</div><!-- fragment --><p>As you can see, this specialization pulls the min and max values from <code><a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a></code> type and sets them to <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code>. This way <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code> finds out the valid range of values by simply being bound to value that has constraints encoded inside its type. </p><div class="fragment"><div class="line">_new&lt;ANumberPicker&gt;() &amp;&amp; user-&gt;age,</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We're using <code>operator&amp;&amp;</code> here to set up bidirectional connection. For more info, go to "Declarative_bidirectional_connection".</dd></dl>
<p><a class="el" href="namespaceBy.html" title="Matcher factory namespace.">By</a> creating this connection, we've done a little bit more. We've set ANumberPicker::setMin and ANumberPicker::setMax as well: </p><div class="fragment"><div class="line">EXPECT_EQ(numberPicker-&gt;getMin(), 1);</div>
<div class="line">EXPECT_EQ(numberPicker-&gt;getMax(), 99);</div>
</div><!-- fragment --><p>This example demonstrates how to use declarative binding to propagate strong types. <code><a class="el" href="structaui_1_1ranged__number.html" title="Clamps the possible values for a number to the specified range: [min;max].">aui::ranged_number</a></code> propagates its constraints on <code><a class="el" href="classANumberPicker.html" title="A text field for numbers with increase/decrease buttons.">ANumberPicker</a></code> thanks to <code><a class="el" href="structADataBindingDefault.html" title="Defines how View handles properties of FieldType type.">ADataBindingDefault</a></code> specialization.</p>
<h2><a class="anchor" id="Label_via_declarative_projection"></a>
Label via declarative projection</h2>
<p>We can use projections in the same way as with <code>let</code>. </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>declarative;</div>
<div class="line"><span class="keyword">struct </span>User {</div>
<div class="line">    <a class="code" href="structAProperty.html">AProperty&lt;AString&gt;</a> name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> user = <a class="code" href="structaui_1_1ptr.html#a9696eab52bd0745688055a301d9ef776">aui::ptr::manage</a>(<span class="keyword">new</span> User { .name = <span class="stringliteral">&quot;Roza&quot;</span> });</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="classMyWindow.html">MyWindow</a>: <span class="keyword">public</span> <a class="code" href="classAWindow.html">AWindow</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classMyWindow.html">MyWindow</a>(<span class="keyword">const</span> <a class="code" href="class__.html">_&lt;User&gt;</a>&amp; user) {</div>
<div class="line">        <a class="code" href="class__.html">_&lt;ALabel&gt;</a> label;</div>
<div class="line">        setContents(<a class="code" href="structaui_1_1ui__building_1_1layouted__container__factory.html">Centered</a> {</div>
<div class="line">            _new&lt;ALabel&gt;() &amp; user-&gt;name.readProjected(&amp;AString::uppercase)</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> window = _new&lt;MyWindow&gt;(user);</div>
<div class="line">window-&gt;show();</div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Label_via_declarative_projection_1.png" alt="text" class="inline"/></p>
<p>Note that the label already displays the <b>projected</b> value stored in <a class="el" href="structUser.html">User</a>.</p>
<p>Projection applies to value changes as well. Let's change the name: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Vasil&quot;</span>;</div>
<div class="line"> </div>
<div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">&quot;Vasil&quot;</span>);</div>
<div class="line">EXPECT_EQ(label-&gt;text(), <span class="stringliteral">&quot;VASIL&quot;</span>); <span class="comment">// projected</span></div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Label_via_declarative_projection_2.png" alt="text" class="inline"/></p>
<h2><a class="anchor" id="Declarative_bidirectional_connection"></a>
Declarative bidirectional connection</h2>
<p>In previous examples, we've used <code>&amp;</code> to make one directional (one sided) connection. This is perfectly enough for <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> because it cannot be changed by user.</p>
<p>In some cases, you might want to use property-to-property as it's bidirectional. It's used for populating view from model and obtaining data from view back to the model.</p>
<p>For this example, let's use <a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> instead of <a class="el" href="classALabel.html" title="Represents a simple single-line text display view.">ALabel</a> as it's an editable view. In this case, we'd want to use <code>&amp;&amp;</code> because we do want <code>user-&gt;name</code> to be aware of changes of the view. </p><div class="fragment"><div class="line">_new&lt;ATextField&gt;() &amp;&amp; user-&gt;name</div>
</div><!-- fragment --><p>This gives the following result: <img src="imgs/UIDataBindingTest.Declarative_bidirectional_connection_1.png" alt="text" class="inline"/></p>
<p>Let's change the name programmatically: </p><div class="fragment"><div class="line">user-&gt;name = <span class="stringliteral">&quot;Vasil&quot;</span>;</div>
</div><!-- fragment --><p><a class="el" href="classATextField.html" title="Editable field with text to receive a text input from the user.">ATextField</a> will respond: <img src="imgs/UIDataBindingTest.Declarative_bidirectional_connection_2.png" alt="text" class="inline"/></p>
<p>If the user changes the value from UI, these changes will reflect on <code>user-&gt;model</code> as well: <img src="imgs/UIDataBindingTest.Declarative_bidirectional_connection_3.png" alt="text" class="inline"/> </p><div class="fragment"><div class="line">EXPECT_EQ(user-&gt;name, <span class="stringliteral">&quot;Changed from UI&quot;</span>);</div>
</div><!-- fragment --><p>This way we've set up bidirectional projection via <code>&amp;&amp;</code> which makes <code>user-&gt;name</code> aware of UI changes.</p>
<h2><a class="anchor" id="Declarative_bidirectional_projection"></a>
Declarative bidirectional projection</h2>
<p>We can use projections in the same way as with <code>let</code>.</p>
<p>Let's repeat the "Bidirectional_projection" sample in declarative way: </p><div class="fragment"><div class="line">_new&lt;ADropdownList&gt;(gendersStr) &amp;&amp; user-&gt;gender.biProjected(GENDER_INDEX_PROJECTION) &gt; &amp;<a class="code" href="classADropdownList.html#a943759a1bb9bb69a40ee9b2bca0ae088">ADropdownList::selectionId</a></div>
<div class="ttc" id="aclassADropdownList_html_a943759a1bb9bb69a40ee9b2bca0ae088"><div class="ttname"><a href="classADropdownList.html#a943759a1bb9bb69a40ee9b2bca0ae088">ADropdownList::selectionId</a></div><div class="ttdeci">auto selectionId() const</div><div class="ttdoc">Selected id property.</div><div class="ttdef"><b>Definition:</b> ADropdownList.h:50</div></div>
</div><!-- fragment --><p><img src="imgs/UIDataBindingTest.Declarative_bidirectional_projection_1.png" alt="dropdownlist" class="inline"/> </p><dl class="section note"><dt>Note</dt><dd>We used the <code>&amp;&amp;</code> operator here instead of <code>&amp;</code> because we want the connection work in both directions: <code>user.gender -&gt; <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a></code> and <code><a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> -&gt; user.gender</code>.</dd></dl>
<ul>
<li>If we try to change <code>user-&gt;gender</code> programmatically, <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a> will respond: <div class="fragment"><div class="line">user-&gt;gender = Gender::FEMALE;</div>
<div class="line">EXPECT_EQ(dropdownList-&gt;getSelectedId(), 1); <span class="comment">// second option</span></div>
</div><!-- fragment --></li>
</ul>
<p><img src="imgs/UIDataBindingTest.Declarative_bidirectional_projection_2.png" alt="dropdownlist" class="inline"/></p>
<ul>
<li>If the user changes the value of <a class="el" href="classADropdownList.html" title="A button with dropdown list.">ADropdownList</a>, it reflects on the model as well: <div class="fragment"><div class="line">EXPECT_EQ(user-&gt;gender, Gender::OTHER);</div>
</div><!-- fragment --></li>
</ul>
<p><img src="imgs/UIDataBindingTest.Declarative_bidirectional_projection_3.png" alt="dropdownlist" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md153"></a>
Functions</h1>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0c76a7210b013192927851449a923992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c76a7210b013192927851449a923992">&#9670;&nbsp;</a></span>biConnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;APropertyWritable PropertySource, APropertyWritable PropertyDestination&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AObject::biConnect </td>
          <td>(</td>
          <td class="paramtype">PropertySource &amp;&amp;&#160;</td>
          <td class="paramname"><em>propertySource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyDestination &amp;&amp;&#160;</td>
          <td class="paramname"><em>propertyDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects source property to the destination property and opposite (bidirectionally). </p>
<p>Connects <code>propertySource.changed</code> to the setter of <code>propertyDestination</code> . Additionally, sets the <code>propertyDestination</code> with the current value of the <code>propertySource</code> (pre-fire). Hence, initial dataflow is from left argument to the right argument.</p>
<p>After pre-fire, connects <code>propertyDestination.changed</code> to the setter of <code>propertySource</code> . This way, when <code>propertyDestination</code> changes (i.e, <code>propertyDestination</code> belongs to some view and it's value is changed due to user action) it immediately reflects on <code>propertySource</code> . So, <code>propertySource</code> is typically a property of some view model with prefilled interesting data, and propertyDestination is a property of some view whose value is unimportant at the moment of connection creation.</p>
<p>biConnect pulls <a class="el" href="classAObject.html" title="A base object class.">AObject</a> from <code>propertySource</code> and <code>propertyDestination</code> to maintain the connection.</p>
<p>See <a class="el" href="group__signal__slot.html">signal-slot system</a> for more info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertySource</td><td>source property, whose value is preserved on connection creation. </td></tr>
    <tr><td class="paramname">propertyDestination</td><td>destination property, whose value is overwritten on connection creation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f8cf4730e29a445ec920748d55b77c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8cf4730e29a445ec920748d55b77c5">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;APropertyReadable PropertySource, APropertyWritable PropertyDestination&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AObject::connect </td>
          <td>(</td>
          <td class="paramtype">PropertySource &amp;&amp;&#160;</td>
          <td class="paramname"><em>propertySource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyDestination &amp;&amp;&#160;</td>
          <td class="paramname"><em>propertyDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects source property to the destination property. </p>
<p>Connects <code>propertySource.changed</code> to the setter of <code>propertyDestination</code> . Additionally, sets the <code>propertyDestination</code> with the current value of the <code>propertySource</code> (pre-fire). Hence, dataflow is from left argument to the right argument.</p>
<p>connect pulls <a class="el" href="classAObject.html" title="A base object class.">AObject</a> from <code>propertyDestination</code> to maintain the connection.</p>
<p>See <a class="el" href="group__signal__slot.html">signal-slot system</a> for more info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertySource</td><td>source property, whose value is preserved on connection creation. </td></tr>
    <tr><td class="paramname">propertyDestination</td><td>destination property, whose value is overwritten on connection creation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<div class="dynheader">
Collaboration diagram for Property System:</div>
<div class="dyncontent">
<div class="center"><img src="group__property__system.png" border="0" usemap="#agroup____property____system" alt=""/></div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
</body>
</html>
